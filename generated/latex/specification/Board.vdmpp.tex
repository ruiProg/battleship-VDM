\begin{vdmpp}[breaklines=true]
class Board
types
 public CellContent = <Empty> | <Carrier> | <Battleship> | <Cruiser> | <Submarine> | <Destroyer> | <Hit> | <Miss>;
 public Direction = <Up> | <Down> | <Left> | <Right>

values
 protected static shipSize: map CellContent to nat1 = {
  <Carrier> |-> 5, <Battleship> |-> 4, <Cruiser> |-> 3, <Submarine> |-> 3, <Destroyer> |-> 2
 };
 protected static colMap: map char to nat1 = {
  'A' |-> 1, 'B' |-> 2, 'C' |-> 3, 'D' |-> 4, 'E' |-> 5, 'F' |-> 6, 'G' |-> 7, 'H' |-> 8, 'I' |-> 9, 'J' |-> 10
 }; -- índice de cada coluna

instance variables
 protected cells: seq of seq of CellContent := []; --matriz de células
 
 inv len cells = 10; -- cada tabuleiro tem 10 linhas
 inv card {i| i in set inds cells & len cells(i) = 10} = 10; -- cada linha tem 10 colunas
(*@
\label{Board:19}
@*)
 
operations
--cria tabuleiro com todas células vazias
 public Board: () ==> Board
  Board() == (
   cells := [[<Empty>| x in set {1,...,10}]| x in set {1,...,10}];
(*@
\label{setComponent:25}
@*)
   return self;
  );
  
--preenche a célula (line,col) com content
 public setComponent: CellContent * nat1 * nat1 ==> ()
  setComponent(content, line, col) == (
(*@
\label{setComponentCol:31}
@*)
   cells(line) := cells(line) ++ {col |-> content}
  )
  pre col <= 10 and line <= 10 and content <> <Empty>;

(*@
\label{emptyValidCells:35}
@*)
--mapeia coluna para índice e chama função para preencher célula
(*@
\label{getComponent:36}
@*)
 public setComponentCol: CellContent * nat1 * char ==> ()
  setComponentCol(content, line, colCh) == setComponent(content, line, colMap(colCh))
  pre colCh in set dom colMap;

-- tendo a célula A=(line,col) e size-1 céulas numa determinada direcção (dir)
-- todas estas células estão dentro dos limites do tabuleiro e estão vazias
 pure public emptyValidCells: nat1 * nat1 * Direction * nat1 ==> bool
  emptyValidCells(line, col, dir, size) == (
   if dir = <Up> then
    for i = 0 to size - 1 do (
     if line - i <= 0 then return false;
     if cells(line - i)(col) <> <Empty> then return false;
     )
   else if dir = <Down> then
    for i = 0 to size - 1 do (
     if line + i > 10 then return false;
     if cells(line + 1)(col) <> <Empty> then return false;
     )
   else if dir = <Left> then
    for i = 0 to size - 1 do (
     if col - i <= 0 then return false;
     if cells(line)(col - i) <> <Empty> then return false;
     )
(*@
\label{countCellType:59}
@*)
   else for i = 0 to size - 1 do (
     if col + i > 10 then return false;
     if cells(line)(col + i) <> <Empty> then return false;
     );
   return true;
  );
  
-- verifica o número de células do tabuleiro preenchidas com determinada componente
 pure public countCellType: CellContent ==> nat
(*@
\label{placeShip:68}
@*)
  countCellType(type) == (
   dcl sum : nat := 0;
   for i = 1 to len cells do
    for j = 1 to len cells(i) do
     if cells(i)(j) = type then sum := sum + 1;
   return sum;
  );

-- coloca um navio no tabuleiro dada célula A=(line, colCh) numa determinada direcção
 public placeShip: CellContent * char * nat1 * Direction ==> ()
  placeShip(ship, colCh, line, dir) == (
   dcl col: nat1 := colMap(colCh);
   if dir = <Up> then
    for i = 0 to shipSize(ship) - 1 do
     setComponent(ship, line - i, col)
   else if dir = <Down> then
    for i = 0 to shipSize(ship) - 1 do
     setComponent(ship, line + i, col)
   else if dir = <Left> then
    for i = 0 to shipSize(ship) - 1 do
     setComponent(ship, line, col - i)
(*@
\label{getShips:89}
@*)
   else for i = 0 to shipSize(ship) - 1 do
     setComponent(ship, line, col + i)
  )
(*@
\label{getShipsCount:92}
@*)
  pre ship in set dom shipSize
  and colCh in set dom colMap
  and countCellType(ship) = 0
(*@
\label{registerMove:95}
@*)
  and emptyValidCells(line, colMap(colCh), dir, shipSize(ship)) --check if cells that a ship takes are empty and if ship fits in the board
  post countCellType(ship) = shipSize(ship); 
  
-- retorna a lista de navios numa frota
 public getShips : () ==> set of CellContent
  getShips() == return dom shipSize;
  
-- retorna o número de navios numa frota
 public getShipsCount : () ==> int
  getShipsCount() == return card dom shipSize;

-- verifica se numa célula existe um navio e regista com <Hit> ou <Miss>
 public registerMove: char * nat1 ==> CellContent
(*@
\label{shipToString:108}
@*)
  registerMove(colCh, line) == (
   dcl col: nat1 := colMap(colCh);
   dcl oldValue: CellContent := cells(line)(col);
   if oldValue = <Empty> then cells(line)(col) := <Miss>
   else cells(line)(col) := <Hit>;
   return oldValue;
  )
  pre colCh in set dom colMap and cells(line)(colMap(colCh)) not in set {<Hit>,<Miss>}
  post cells(line)(colMap(colCh)) in set {<Hit>,<Miss>};
  
--- print to console
  
 -- retorna o navio em string
 public shipToString : CellContent ==> Player`String
  shipToString(type) == (
(*@
\label{cellToString:123}
@*)
   cases type:
   <Empty> -> return "Empty",
   <Carrier> -> return "Carrier",
   <Battleship> -> return "Battleship",
   <Cruiser> -> return "Cruiser",
   <Submarine> -> return "Submarine",
(*@
\label{printBoard:129}
@*)
   <Destroyer> -> return "Destroyer",
   <Hit> -> return "Hit",
   <Miss> -> return "Miss"
   end;
   return "Unknow"
  );
  
  -- retorna a representação de um navio no tabuleiro
 public cellToString : CellContent ==> Player`String
  cellToString(type) == (
   dcl fullStr: Player`String := shipToString(type);
(*@
\label{printParallelBoards:140}
@*)
   return [fullStr(i)| i in set inds fullStr & i < 4];
  );
  
  -- imprime um tabuleiro e peças lá inseridas
 public printBoard : () ==> Player`String
  printBoard() == (
   dcl board: Player`String := [];
   for i = 1 to len cells do (
    if i < 10 then board := board ^ "0";
    board := board ^ VDMUtil`val2seq_of_char[nat](i) ^ "    ";
    for j = 1 to len cells(i) do board:= board ^ cellToString(cells(i)(j)) ^ "    ";
    board := board ^ "\n";
   );
   return "      A      B      C      D      E      F      G      H      I      J    \n\n" ^ board);
 
 -- imprime dois tabuleiros lado a lado
 public printParallelBoards : Board  ==> Player`String
  printParallelBoards(enemyBoard) == (
   dcl pBoard: Player`String := [];
(*@
\label{printRemainShips:159}
@*)
   for i = 1 to len cells do (
    if i < 10 then pBoard := pBoard ^ "0";
    pBoard := pBoard ^ VDMUtil`val2seq_of_char[nat](i) ^ "    ";
    for j = 1 to len cells(i) do pBoard:= pBoard ^ cellToString(cells(i)(j)) ^ "    ";
    
    pBoard := pBoard ^ "\t\t\t";
    if i < 10 then pBoard := pBoard ^ "0";
    pBoard := pBoard ^ VDMUtil`val2seq_of_char[nat](i) ^ "    ";
    for j = 1 to len enemyBoard.cells(i) do pBoard:= pBoard ^ cellToString(enemyBoard.cells(i)(j)) ^ "    ";
    
    pBoard := pBoard ^ "\n";
   );
   return "      A      B      C      D      E      F      G      H      I      J    " ^
   "\t\t\t" ^ "      A      B      C      D      E      F      G      H      I      J    \n\n" ^ pBoard);
   
 -- imprime os navios de uma lista em formato string
 public printRemainShips: set of CellContent ==> Player`String
  printRemainShips(ships) == (
   dcl res: Player`String := [];
   for all ship in set ships do res := res ^ shipToString(ship) ^ ": " ^ VDMUtil`val2seq_of_char[nat](shipSize(ship)) ^ "    ";
   return res;
  )
 
end Board
\end{vdmpp}
\bigskip
\begin{longtable}{|l|r|r|r|}
\hline
Function or operation & Line & Coverage & Calls \\
\hline
\hline
\hyperref[Board:19]{Board} & 19&100.0\% & 4 \\
\hline
\hyperref[cellToString:123]{cellToString} & 123&0.0\% & 0 \\
\hline
\hyperref[countCellType:59]{countCellType} & 59&100.0\% & 1 \\
\hline
\hyperref[emptyValidCells:35]{emptyValidCells} & 35&0.0\% & 0 \\
\hline
\hyperref[getComponent:36]{getComponent} & 36&0.0\% & 0 \\
\hline
\hyperref[getShips:89]{getShips} & 89&0.0\% & 0 \\
\hline
\hyperref[getShipsCount:92]{getShipsCount} & 92&0.0\% & 0 \\
\hline
\hyperref[placeShip:68]{placeShip} & 68&0.0\% & 0 \\
\hline
\hyperref[printBoard:129]{printBoard} & 129&0.0\% & 0 \\
\hline
\hyperref[printParallelBoards:140]{printParallelBoards} & 140&0.0\% & 0 \\
\hline
\hyperref[printRemainShips:159]{printRemainShips} & 159&0.0\% & 0 \\
\hline
\hyperref[registerMove:95]{registerMove} & 95&0.0\% & 0 \\
\hline
\hyperref[setComponent:25]{setComponent} & 25&100.0\% & 2 \\
\hline
\hyperref[setComponentCol:31]{setComponentCol} & 31&100.0\% & 1 \\
\hline
\hyperref[shipToString:108]{shipToString} & 108&0.0\% & 0 \\
\hline
\hline
Board.vdmpp & & 22.5\% & 8 \\
\hline
\end{longtable}

