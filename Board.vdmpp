class Board
types
	public CellContent = <Empty> | <Carrier> | <Battleship> | <Cruiser> | <Submarine> | <Destroyer> | <Hit> | <Miss>;
	public Direction = <Up> | <Down> | <Left> | <Right>

instance variables
	private cells: seq of seq of CellContent := [];
	private static shipSize: map CellContent to nat1 := {
		<Carrier> |-> 5, <Battleship> |-> 4, <Cruiser> |-> 3, <Submarine> |-> 3, <Destroyer> |-> 2
	};
	private static colMap: map char to nat1 := {
		'A' |-> 1, 'B' |-> 2, 'C' |-> 3, 'D' |-> 4, 'E' |-> 5, 'F' |-> 6, 'G' |-> 7, 'H' |-> 8, 'I' |-> 9, 'J' |-> 10
	};
	
	inv len cells = 10;
	inv card {i| i in set inds cells & len cells(i) = 10} = 10;
	
operations
	public Board: () ==> Board
		Board() == (
			cells := [[<Empty>| x in set {1,...,10}]| x in set {1,...,10}];
			return self;
		);
		
	public setComponent: CellContent * nat1 * nat1 ==> ()
		setComponent(ship, line, col) == (
			cells(line) := cells(line) ++ {col |-> ship}
		)
		pre col <= 10 and line <= 10;
		
	pure public emptyValidCells: nat1 * nat1 * Direction * nat1 ==> bool
		emptyValidCells(line, col, dir, size) == (
			if dir = <Up> then
				for i = 0 to size - 1 do (
					if line - i <= 0 then return false;
					if cells(line - i)(col) <> <Empty> then return false;
					)
			else if dir = <Down> then
				for i = 0 to size - 1 do (
					if line + i > 10 then return false;
					if cells(line + 1)(col) <> <Empty> then return false;
					)
			else if dir = <Left> then
				for i = 0 to size - 1 do (
					if col - i <= 0 then return false;
					if cells(line)(col - i) <> <Empty> then return false;
					)
			else for i = 0 to size - 1 do (
					if col + i > 10 then return false;
					if cells(line)(col + i) <> <Empty> then return false;
					);
			return true;
		);
		
	pure public countCellType: CellContent ==> nat
		countCellType(type) == (
			dcl sum : nat := 0;
			for i = 1 to len cells do
				for j = 1 to len cells(i) do
					if cells(i)(j) = type then sum := sum + 1;
			return sum;
		);
		
	public placeShip: CellContent * char * nat1 * Direction ==> ()
		placeShip(ship, colCh, line, dir) == (
			dcl col: nat1 := colMap(colCh);
			if dir = <Up> then
				for i = 0 to shipSize(ship) - 1 do
					setComponent(ship, line - i, col)
			else if dir = <Down> then
				for i = 0 to shipSize(ship) - 1 do
					setComponent(ship, line + i, col)
			else if dir = <Left> then
				for i = 0 to shipSize(ship) - 1 do
					setComponent(ship, line, col - i)
			else for i = 0 to shipSize(ship) - 1 do
					setComponent(ship, line, col + i)
		)
		pre ship in set dom shipSize
		and colCh in set dom colMap
		and countCellType(ship) = 0
		and emptyValidCells(line, colMap(colCh), dir, shipSize(ship)) --check if cells that a ship takes are empty and if ship fits in the board
		post countCellType(ship) = shipSize(ship);	
		
	public getShips : () ==> set of CellContent
		getShips() == return dom shipSize;
		
	public getShipsCount : () ==> int
		getShipsCount() == return card dom shipSize;
		
	public registerMove: char * nat1 ==> CellContent
		registerMove(colCh, line) == (
			dcl col: nat1 := colMap(colCh);
			dcl oldValue: CellContent := cells(line)(col);
			if oldValue = <Empty> then cells(line)(col) := <Miss>
			else cells(line)(col) := <Hit>;
			return oldValue;
		)
		pre cells(line)(colMap(colCh)) not in set {<Hit>,<Miss>}
		post cells(line)(colMap(colCh)) in set {<Hit>,<Miss>};
		
		--- print to console
		
	public shipToString : CellContent ==> Player`String
		shipToString(type) == (
			cases type:
			<Empty> -> return "Empty",
			<Carrier> -> return "Carrier",
			<Battleship> -> return "Battleship",
			<Cruiser> -> return "Cruiser",
			<Submarine> -> return "Submarine",
			<Destroyer> -> return "Destroyer",
			<Hit> -> return "Hit",
			<Miss> -> return "Miss"
			end;
			return "Unknow"
		);
		
	public cellToString : CellContent ==> Player`String
		cellToString(type) == (
			dcl fullStr: Player`String := shipToString(type);
			return [fullStr(i)| i in set inds fullStr & i < 4];
		);
		
	public printBoard : () ==> Player`String
		printBoard() == (
			dcl board: Player`String := [];
			for i = 1 to len cells do (
				if(i < 10) then board := board ^ "0";
				board := board ^ VDMUtil`val2seq_of_char[nat](i) ^ "    ";
				for j = 1 to len cells(i) do board:= board ^ cellToString(cells(i)(j)) ^ "    ";
				board := board ^ "\n";
			);
			return "      A      B      C      D      E      F      G      H      I      J    \n\n" ^ board);
	
	public printRemainShips: set of CellContent ==> Player`String
		printRemainShips(ships) == (
			dcl res: Player`String := [];
			for all ship in set ships do res := res ^ shipToString(ship) ^ ": " ^ VDMUtil`val2seq_of_char[nat](shipSize(ship)) ^ "    ";
			return res;
		)
	
end Board